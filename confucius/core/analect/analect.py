# Copyright (c) Meta Platforms, Inc. and affiliates.
# pyre-strict
from __future__ import annotations

from abc import ABC, abstractmethod
from contextlib import asynccontextmanager
from contextvars import ContextVar
from typing import Any, AsyncGenerator, Generic, Optional, override, Sequence, Set, Type

from langchain_core.callbacks.manager import (
    AsyncCallbackManager,
    AsyncCallbackManagerForChainRun,
    AsyncParentRunManager,
)

from langchain_core.runnables import Runnable, RunnableConfig
from langchain_core.runnables.utils import Input as LCInput, Output as LCOutput
from pydantic import BaseModel, Field, PrivateAttr

from ...utils.asyncio import await_sync

from .. import types as cf
from ..artifact import Artifacts
from ..io import IOInterface

from ..llm_manager import LLMManager

from ..memory import CfMemory, CfMemoryManager, ChildContextOptions
from ..storage import Storage
from .base import AnalectBase, Input, Output

_run_context: ContextVar[AnalectRunContext] = ContextVar("cf_run_context")

CF_RUNNABLE_KEY = "cf_runnable"


def issubclass_by_name(cl: Type[object], parent: Type[object]) -> bool:
    if cl.__module__ == parent.__module__ and cl.__name__ == parent.__name__:
        return True
    for b_class in cl.__bases__:
        if issubclass_by_name(b_class, parent):
            return True
    return False


def isinstance_by_name(o: object, t: Type[object]) -> bool:
    # built-in isinstance() check
    if isinstance(o, t):
        return True

    # module + name check
    return issubclass_by_name(o.__class__, t)


def get_current_context(
    *,
    run_manager: None | AsyncParentRunManager = None,
) -> AnalectRunContext:
    """
    This is an experimental feature, and for now should only be used by Confucius
    framework developers.

    Users might have a need to access the current run context where it might not be
    straightforward to pass down the context properly via arguments. For example:
    1. If users want to invoke an analect within a vanilla Langchain Chain, user
       will not have easy access to the current run context.
    2. If users want to use the context inside IO interface, that is also awkward,
       since IO interface must have depenency on the context to avoid circular
       dependencies.

    If run_manager is provided, we will make a copy of the context, and override
    the given run manager.
    """
    try:
        context = _run_context.get()
    except LookupError as e:
        raise RuntimeError(
            f"Unable to find a current run context: {e}. "
            "Please make sure to only use this method inside Confucius execution environment."
        )

    # For now, we always make a copy. We can revisit this if there are legit use cases
    # where we want to access the exact context instance.
    context = context.model_copy()

    if run_manager is not None:
        context._run_manager = run_manager

    return context


def _update_current_context_with_run_manager(
    run_manager: None | AsyncParentRunManager = None,
) -> AnalectRunContext:
    """
    This is a private method. It should only be used within Confucius core framework.

    This method updates the current context with the given run manager, and returns it.
    """
    try:
        context = _run_context.get()
    except LookupError as e:
        raise RuntimeError(
            f"Unable to find a current run context: {e}. "
            "Please make sure to only use this method inside Confucius execution environment."
        )

    context._run_manager = run_manager
    return context


class AnalectRunContext(BaseModel):
    """
    Confucius framework users should assume this context is already constructed
    and ready to use. Framework users should never have to manually construct
    this context.
    """

    session: str = Field(..., description="session ID")
    io: IOInterface = Field(..., description="the generic IO interface")
    llm_manager: LLMManager = Field(..., description="LLM manager for the analect")
    session_storage: Storage = Field(
        ...,
        description=(
            "[Experimental] this is a in-memory key-value storage (e.g. a dict-equivalent) that is "
            "persisted across the session. This means the storage could contain leftover "
            "objects from unrelated entry analects, and that your objects may be potentially "
            "accessible or overwriten by other entries. To prevent cross-contaminations like "
            "these. Different use cases are encouraged to use different namespaces."
        ),
    )
    artifacts: Artifacts = Field(
        ...,
        description="the artifacts that are generated by the analect",
    )
    namespace_id: Sequence[str] = Field(
        [],
        description="the namespace ID of the current analect",
    )
    memory_manager: CfMemoryManager = Field(
        ..., description="memory manager of the analect"
    )
    cat_token: str | None = Field(
        None, description="the CAT token for the current session"
    )
    runnable: Runnable | None = Field(
        None, description="the runnable that is currently being executed"
    )
    user: str = Field(
        "", description="the user that is currently executing the analect"
    )

    """
    [Private] The callback manager for this call. This is considered private
    to the Confucius framework internals and users should NOT have to interact with this field
    directly.
    * None: (1) in first context that is constructed by top-level Confucius
    *       or (2) in some unit tests.
    * AsyncParentRunManager: in any other situations
    """
    _run_manager: None | AsyncParentRunManager = None

    class Config:
        """Configuration for this pydantic object."""

        arbitrary_types_allowed = True
        extra = "forbid"

    def _get_child_run_manager(self) -> AsyncCallbackManager | None:
        """
        Get the child run manager.
        """
        if self._run_manager:
            assert isinstance(
                self._run_manager, AsyncParentRunManager
            ), f"[Internal Error] expecting run_manager to be AsyncParentRunManager, got: {type(self._run_manager)}"

        return self._run_manager.get_child() if self._run_manager else None

    @asynccontextmanager
    async def child_context_and_callbacks(
        self,
        runnable: Runnable | None = None,
        child_context_options: Optional[ChildContextOptions] = None,
        _child_retained_message_types: Optional[Set[cf.MessageType]] = None,
    ) -> AsyncGenerator[tuple[AnalectRunContext, AsyncCallbackManager | None], None]:
        child_run_manager = self._get_child_run_manager()
        child_context = self.model_copy(update={"runnable": runnable})

        # Set child_context's memory manager and memory options
        child_context.memory_manager = CfMemoryManager(
            memory=CfMemory(),
            parent_memory=self.memory_manager,
            entry_name=self.memory_manager.entry_name,
            runnable=runnable,
        )

        token = _run_context.set(child_context)
        try:
            yield (child_context, child_run_manager)
        finally:
            self.memory_manager.consolidate_messages(
                child_context.memory_manager,
                child_context_options,
                _child_retained_message_types,
            )
            _run_context.reset(token)

    async def _invoke_runnable(
        self,
        other: Runnable[LCInput, LCOutput],
        inp: LCInput,
        config: RunnableConfig | None = None,
        options: Optional[ChildContextOptions] = None,
        **kwargs: Any | None,
    ) -> LCOutput:
        """
        Implementation of invoke_runnable.
        """
        # For a split second, the run_manager inside 'child_context' is for the parent run, and the
        # callback is for the child run. That will be fixed as soon as we get to Analect's '_acall',
        # which will properly construct the child run context.
        async with self.child_context_and_callbacks(
            runnable=other, child_context_options=options
        ) as (
            child_context,
            callbacks,
        ):
            if config is None:
                config = RunnableConfig()
            else:
                config = config.copy()

            if "metadata" not in config:
                config["metadata"] = {}

            config["callbacks"] = config.get("callbacks", callbacks)
            config["metadata"]["child_context_options"] = options
            config["metadata"][CF_RUNNABLE_KEY] = other

            output_dict = await other.ainvoke(
                inp,
                config=config,
                **kwargs,
            )
            return output_dict

    async def _invoke_analect(
        self,
        other: Analect[Input, Output],
        inp: Input,
        config: RunnableConfig | None = None,
        options: Optional[ChildContextOptions] = None,
        **kwargs: Any | None,
    ) -> Output:
        """
        Implementation of invoke_analect.
        """
        # For a split second, the run_manager inside 'child_context' is for the parent run, and the
        # callback is for the child run. That will be fixed as soon as we get to Analect's '_acall',
        # which will properly construct the child run context.
        async with self.child_context_and_callbacks(
            runnable=other,
            child_context_options=options,
            _child_retained_message_types=other.cf_retained_message_types(),
        ) as (
            child_context,
            callbacks,
        ):
            if config is None:
                config = RunnableConfig()
            else:
                config = config.copy()

            if "metadata" not in config:
                config["metadata"] = {}

            config["callbacks"] = config.get("callbacks", callbacks)
            config["metadata"]["child_context_options"] = options
            config["metadata"][CF_RUNNABLE_KEY] = other

            out = await other.ainvoke(
                inp,
                config=config,
                return_only_outputs=True,
                **kwargs,
            )
            return out

    async def invoke_runnable(
        self,
        other: Runnable[LCInput, LCOutput] | Analect[Input, Output],
        inp: LCInput | Input,
        config: RunnableConfig | None = None,
        options: Optional[ChildContextOptions] = None,
        **kwargs: Any | None,
    ) -> LCOutput | Output:
        """
        Invoke another runnable with the given input.

        The method does the following:
        1. pass down callback manager
        2. maintain the same interface as other.ainvoke
        """
        if isinstance(other, Analect):
            if not isinstance_by_name(inp, other.get_input_type()):
                raise ValueError(
                    f"When invoking {type(other)}, expecting argument to be of type {other.get_input_type()}, but got: {type(inp)}."
                )
            assert isinstance(
                inp, BaseModel
            ), f"Input must be a Pydantic BaseModel, but got {type(inp)}"
            output = await self._invoke_analect(
                other,
                inp,
                config=config,
                options=options,
                **kwargs,
            )
            return output

        return await self._invoke_runnable(
            # pyre-ignore: Incompatible parameter type [6]: In call `AnalectRunContext._invoke_runnable`, for 1st positional argument, expected `Runnable[Variable[LCInput](contravariant), Variable[LCOutput](covariant)]` but got `Runnable[Variable[LCInput](contravariant), Variable[LCOutput](covariant)]`.
            other,
            inp,
            config=config,
            options=options,
            **kwargs,
        )

    async def invoke(
        self,
        other: Runnable[LCInput, LCOutput] | Analect[Input, Output],
        inp: LCInput | Input,
        config: RunnableConfig | None = None,
        options: Optional[ChildContextOptions] = None,
        **kwargs: Any | None,
    ) -> LCOutput | Output:
        """
        Alias of invoke_runnable.
        """
        return await self.invoke_runnable(
            other, inp, config=config, options=options, **kwargs
        )

    async def invoke_analect(
        self,
        other: Any,
        inp: Input,
        config: RunnableConfig | None = None,
        options: Optional[ChildContextOptions] = None,
        **kwargs: Any,
    ) -> Any:
        """
        Invoke another Analect with the given input.

        The method does the following:
        1. pass down callback manager and run context
        2. maintain an obj-in, obj-out call interface

        Note that arguments that starts with _ are considered
        internal to Confucius framework and should not be used by users.
        """
        if not isinstance(other, Analect):
            raise ValueError(
                f"Expecting 'other' to be an instance of Analect, but it is a {type(other)}."
            )

        return await self.invoke_runnable(
            other, inp, config=config, options=options, **kwargs
        )


class Analect(AnalectBase[Input, Output], ABC):
    _run_type: str = PrivateAttr(default="analect")

    class Config:
        """Configuration for this pydantic object."""

        extra = "forbid"
        arbitrary_types_allowed = True

    @classmethod
    def get_input_type(cls) -> Type[Input]:
        return cls._get_input_output()[0]

    @classmethod
    def get_output_type(cls) -> Type[Output]:
        return cls._get_input_output()[1]

    @classmethod
    @override
    # pyre-fixme[24]: Invalid type parameters [24]: Generic type `Analect` expects 2 type parameters.
    def _input_output_type_search_base(cls) -> Type["Analect"]:
        return Analect

    def invoke(
        self, input: Input, config: Optional[RunnableConfig] = None, **kwargs: Any
    ) -> Output:
        res = await_sync(self.ainvoke(input, config=config))
        return res

    @abstractmethod
    async def impl(self, inp: Input, context: AnalectRunContext) -> Output:
        """Implementation of the analect.
        Args:
            inp: the input to the analect
            context: the run context
        Returns:
            the output of the analect
        """

    async def ainvoke(
        self, input: Input, config: Optional[RunnableConfig] = None, **kwargs: Any
    ) -> Output:
        # We delegated call to _acall_with_config to reuse LangChain logic, but in exchange,
        # we need to convert dict and Input/Output back and forth.
        #
        # This is because when _acall_with_config invokes on_chain_start/on_chain_end,
        # where tracing is done internally, it should take dict for better input/output
        # readability on Confucius Dev UI.
        #
        # _acall_with_config basically passes input to our self._ainvoke and returns the
        # output back to us without any manipulation. Hence, it should be safe to ignore
        # the type checker here because our self._ainvoke is taking dict as input, output.
        #
        # The key trick is that - the input and output for this trace wrapper are completely unused
        # and for trace logging only. The actual input and return channel is performed outside.

        output: Output

        async def ainvoke_trace_wrapper(
            _input_ignored,
            run_manager: AsyncCallbackManagerForChainRun,
            config: RunnableConfig,
            **kwargs: Any,
        ) -> dict[str, Any]:
            nonlocal output
            assert run_manager is not None, "run_manager is not expected to be None"
            run_context = _update_current_context_with_run_manager(
                run_manager=run_manager
            )
            output = await self.impl(input, run_context)
            return self.cf_get_trace_output_content(output)

        run_type = kwargs.pop("run_type", self._run_type)
        await self._acall_with_config(
            func=ainvoke_trace_wrapper,
            # pyre-ignore: Incompatible parameter type [6]: In call `langchain_core.runnables.base.Runnable._acall_with_config`, for argument `input`, expected `Variable[Input (bound to BaseModel)]` but got `Dict[str, typing.Any]`.
            input_=self.cf_get_trace_input_content(input),
            config=config,
            run_type=run_type,
            **kwargs,
        )
        return output

    async def invoke_runnable(
        self,
        other: Runnable[LCInput, LCOutput],
        inp: LCInput,
        options: Optional[ChildContextOptions] = None,
    ) -> LCOutput:
        return await get_current_context().invoke_runnable(other, inp, options=options)

    async def invoke_analect(
        self,
        # pyre-fixme[24]: Generic type `Analect` expects 2 type parameters.
        other: Analect,
        inp: Any,
        options: Optional[ChildContextOptions] = None,
    ) -> Any:
        return await get_current_context().invoke_analect(other, inp, options=options)

    def cf_get_trace_input_content(self, inp: Input) -> dict[str, Any]:
        return inp.__dict__

    def cf_get_trace_output_content(self, out: Output) -> dict[str, Any]:
        return out.__dict__

    def cf_retained_message_types(self) -> Set[cf.MessageType]:
        return {cf.MessageType.HUMAN, cf.MessageType.AI, cf.MessageType.SYS}
