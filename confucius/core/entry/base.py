# Copyright (c) Meta Platforms, Inc. and affiliates.
# pyre-strict
import json
from abc import ABC, abstractmethod
from typing import Any, Dict

from pydantic import BaseModel, Field, validator

from .. import types as cf


class LocalOnlyEnvironmentError(RuntimeError):
    pass


class EntryInput(BaseModel):
    question: str = Field(..., description="the user question")
    entry_name: str | None = Field(None, description="entry name")
    attachments: list[cf.MessageAttachment] = Field([], description="input attachments")

    class Config:
        arbitrary_types_allowed = True

    @validator("attachments", pre=True)
    def validate_attachments(
        cls,  # noqa: B902
        v: list[cf.MessageAttachment | Dict[str, Any] | str],
    ) -> list[cf.MessageAttachment]:
        out: list[cf.MessageAttachment] = []
        for a in v:
            if isinstance(a, cf.MessageAttachment):
                out.append(a)
            elif isinstance(a, dict):
                out.append(cf.MessageAttachment(**a))
            elif isinstance(a, str):
                try:
                    parsed = json.loads(a)
                    if isinstance(parsed, dict):
                        out.append(cf.MessageAttachment(**parsed))
                    else:
                        raise ValueError("attachments string must be JSON object")
                except json.JSONDecodeError as e:
                    raise ValueError(f"Invalid attachment JSON: {e}")
            else:
                raise ValueError("Unsupported attachment type")
        return out


class EntryOutput(BaseModel):
    answer: str = Field("", description="answer from analect")
    attachments: list[cf.MessageAttachment] = Field([], description="input attachments")
    r"""The attachments can be anything that you (or the AI) want to attach and display to the users. Usually it's not the same as input attachments.

    Some possible attachments are:
    1. Artifacts generated by the entry;
    2. External links referenced, e.g., wiki, post, etc;
    3. Images, files, etc (not supported yet)

    By default, Confucius framework will not fill the attachments. The entry analect developer are responsible for filling the attachments.
    """

    error_message: str | None = Field(
        None, description="error message attached to the answer"
    )
    warning_message: str | None = Field(
        None, description="warning message attached to the answer"
    )

    class Config:
        arbitrary_types_allowed = True
        # pyre-fixme[4]: Attribute must be annotated.
        json_encoders = {
            cf.MessageAttachment: lambda v: v.model_dump(),
        }

    @validator("attachments", pre=True)
    def validate_attachments(  # noqa: B902
        cls,
        v: list[cf.MessageAttachment | Dict[str, Any] | str],  # noqa
    ) -> list[cf.MessageAttachment]:
        out: list[cf.MessageAttachment] = []
        for a in v:
            if isinstance(a, cf.MessageAttachment):
                out.append(a)
            elif isinstance(a, dict):
                out.append(cf.MessageAttachment(**a))
            elif isinstance(a, str):
                try:
                    parsed = json.loads(a)
                    if isinstance(parsed, dict):
                        out.append(cf.MessageAttachment(**parsed))
                    else:
                        raise ValueError("attachments string must be JSON object")
                except json.JSONDecodeError as e:
                    raise ValueError(f"Invalid attachment JSON: {e}")
            else:
                raise ValueError("Unsupported attachment type")
        return out


class EntryAnalectBase(ABC):
    @classmethod
    @abstractmethod
    def display_name(cls) -> str: ...

    @classmethod
    @abstractmethod
    def description(cls) -> str: ...

    @classmethod
    def input_examples(cls) -> list[EntryInput]:
        return []

    @classmethod
    def tags(cls) -> list[cf.Tag]:
        return []


class EntrySummary(BaseModel):
    name: str | None = Field(None, description="analect name")
    description: str | None = Field(None, description="analect description")


class EntryContextSummary(BaseModel):
    new_question: str = Field(..., description="new question")


class EntryBase(ABC): ...
